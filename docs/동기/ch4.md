# 소중한 메모리.. 공간 효율성

- 공간 효율적인 클래스 작성
- 배열과 리스트, set을 포함한 일반적인 자료 구조 사이의 메모리 요구사항 비교
- 성능과 메모리 사용량 사이의 기회비용 측정
- 메모리 지역성을 활용한 성능 향상


## Memory 1

- 물의 양을 저장하는 필드를```double``` -> ```float```
  - 수조 하나당 4 바이트를 아낄 수 있다
---

```java
public class Container {
    private List<Container> group;
    private float amount;
    
    public float getAmount() {
        return amount;
    } 
}
```
- Set 대신 List를 사용하면 순서가 없고 중복도 없게 하려는 의도는 명시되지 않지만 많은 메모리를 절약할 수 있게됨
- 연결되지 않은 수조 필드는 null
  - 연결이 되는 시점에 리스트를 초기화
- addWater 메서드에서 연결되지 않은 수조의 필드값인 ```null```을  참조하지 않도록 처리를 해준다



### 공간 및 시간 복잡도
- 고립된 수조경우 그룹 참조 4바이트, amount 필드 4바이트, 객체 헤더 12바이트로 이뤄진다. 합 20바이트
  - 초기화된 연결된 수조는 40 + 4n바이트
- 리스트를 필요한 시점에서 초기화하는 방법과 HashSet을 ArrayList로 대체하여 메모리를 상당 수 아낄 수 있었다.
  - 메모리를 절감하여 치러야 할 성능 비용은 없지만 코드 가독성은 이전보다 떨어진다.

## Memory 2

- Memory2 에서는 ArrayList 대신 배열을 사용해서 메모리 사용량을 줄이고 있다.
  - 배열 길이는 그룹 크기와 같게 한다
  - 기존에 addAll 메서드로 두 배열을 병합했다면 ArrayList 대신 배열을 쓰는 상황에서는 두 배열 중 하나를 재할당하여 다른 배열에 복사한다.

### 공간 및 시간 복잡도
- Memory2에서는 Memory1에 비해 공간 절약이 많이 되지 않았다.
  - 고립된 수조 크기 변화는 없고 ArrayList를 일반 배열로 처리했을 때 차이가 크지 않다.
  - 메모리가 절약된 건 배열 길이를 그룹 크기에 딱 맞게 관리했기 때문 ```ArrayList```는 배열 용량을 여유롭게 관리했다.

![IMG_1C3C044524CB-1](https://user-images.githubusercontent.com/73376468/151585201-723e60fd-ea11-422a-bf2f-eebb44f8695f.jpeg)
- 일반 배열과 ArrayList는 메모리 요구 사항 관점에서는 매우 유사하다. 하지만 일반 배열은 여러 편의 기능을 제공하지 않는다.
- ArrayList는 자동 크기 조정을 비롯한 편의 기능을 제공하여 유용하고 높은 추상화를 제공해 코드 가동성을 높이는데 도움을 준다. 제네릭 또한 지원한다.
- HashSet은 여러 기능을 제공한다.
  - 멤버쉽 쿼리를 상수 시간에 제공 (contains)
  - 중복된 요소의 삽입을 상수 시간으로 방지 (add)
  - 임의의 요소를 상수 시간에 제거 (remove)


## Memory 3

- 공간 사용량을 더 줄이기 위해 객체를 버려본다. 하지만 수조를 식별할 수 있어야하기에 수조 정보를 핸들로 클라이언트에게 제공한다.
  - 수조를 객체로 저장하는 대신 정수 ```ID```로 공간을 절약한다.
  - 정수 ```ID```로 공간 효율성이 높은 자료 구조에 필요한 정보를 저장 -> ```배열```
  - 메모리 효율성 때문에 일반 배열을 사용했지만 배열을 사용하면 ```캐시 지역성``` 덕분에 시간 효율성도 높일 수 있다.
    - 메모리상에서 가까운 곳에 있는 데이터를 접근하는 게 흩어진 데이터에 접근하는 것보다 빠르다 ```(CPU 캐시 구조)```
    - 캐시는 소량의 이웃한 데이터를 저장
    - 객체 안의 모든 필드는 메모리상 가까운 곳에 저장되고 한 필드에 접근하면 다른 필드 접근도 빨라진다.
- 자바에서 캐시 지역성을 활용하면서 데이터를 저장하려면 일반 배열 혹은 ArrayList를 사용해야 한다.

### 메모리 계층 구조
- 컴퓨터는 여러 레벨의 계층 구조로 구성
- 아래 레벨로 갈수록 크기는 커지고, 속도는 느려짐
- 최상위 레벨은 CPU 레지스터이며 수백 바이트이다.
  - 레지스터는 CPU의 원래 동작 속도에 맞추는 유일한 메모리 (1 CPU 사이클 안에서 데이터를 읽고 쓸 수 있다)
- 레지스터 아래의 캐시
  - 캐시는 여러 레벨로 나뉘고 수백 메가바이트에 달한다.
  - 최상위 캐시의 읽기는 몇 사이클만 소모하나, 주 메모리로부터 읽는 작업은 수백 사이클을 소모
- 캐시는 여러 개의 라인으로 구성 (한 라인의 크기는 단어 몇 개 정도)

### 팩토리 메서드로 수조 생성하기

- 클래스의 새로운 인스턴스를 리턴하는 메서드를 팩토리 메서드라고 한다.
  - ```newContainer``` 메서드는 새로운 수조 ID를 리턴함으로써 팩토리 메서드의 역할을 한다.

### 인스턴스화 불가능 클래스
- 자바에서는 클래스의 객체를 생성할 수 없도록 컴파일 시점에서 방지하는 몇 가지 방법을 제공한다.
  - 클래스가 아닌 ```인터페이스```로 선언하기
  - 클래스를 ```abstract```로 선언하기
  - (유일한 생성자로) ```private 생성자``` 만들기
    - ```Math``` ```Arrays``` ```Collections``` 유틸리티 클래스를 예로 들 수 있다. 이 클래스들은 상태를 포함하지 않고 편의 기능을 제공하는 역할만 한다.

### 데이터 스트림
```java
private static int groupSize(int groupID) {
    int size = 0;
    for (int otherGroupID: group) {
        if (otherGroupID == groupID) {
            size++;
        }
    }
    return size++;
}
```
```java
return Arrays.stream(group)
        .filter(otherGroupID -> otherGroupID == groupID)
        .count();
```

### 공간 및 시간 복잡도

![IMG_A788F4DEA3D4-1](https://user-images.githubusercontent.com/73376468/151645679-b658403d-4331-4138-96ab-b8d631c34523.jpeg)

- 수조를 객체로 표현하지 않음으로써 공간을 대폭 절약할 수 있었다.
  - 하지만 ```connect``` ```addWater``` 를 모든 수조를 순회하여 처리하게된다.
  - 수조가 많아진다면 성능이 떨어질 수 있다.

## Memory 4

- 수조 하나당 4바이트를 사용하고 시간 복잡도를 희생한다.
  - 정적 배열 하나에 모든 수조를 저장하고 각 요소를 2가지 용도로 사용
    - 하나만 존재하는 배열의 인덱스를 양수 음수로 나누어 `양수`는 `다음 수조 인덱스`, `음수`는 그 수에 `-1을 곱한 수`를 `물의 양`으로 다룬다.
    - 0은 물의 양이라고 정해놓고 수조 인덱스에서는 0을 사용하지 않게한다.
  - 고립된 수조이거나 그룹에 다음 수조가 존재하지 않는다면 그 시점에서 수조에 담긴 물의 양을 저장한다.

![IMG_A48BECCF5E79-1](https://user-images.githubusercontent.com/73376468/151648027-0114bfb0-032a-49aa-b72b-4852b1bcfb50.jpeg)
- 극단적인 메모리 절가믕로 인해 성능 저하가 일어난다.
  - connect 와 addWater 메서드는 수조 리스트의 크기를 알기 위해 첫번째 수조를 찾아 제곱 시간의 복잡도를 사용한다.  
  
![IMG_787DC848FC36-1](https://user-images.githubusercontent.com/73376468/151648309-663690de-6749-4048-bc82-6332d4aaaeda.jpeg)
![IMG_C7FA4A4EE52C-1](https://user-images.githubusercontent.com/73376468/151648330-ecc71bb9-73be-4bb0-bec5-32cf2623393d.jpeg)

- 수행 속도는 이전 챕터에서 speed3이 가장 빨랐고 공간 효율성은 Memory4가 가장 높다. 메모리 효율성을 극대화하면서 시간 복잡도가 2차 함수로 커졌다. 시간과 공간 사이의 기회비용을 잘 보여주고 있다.

### 돌발 퀴즈 1
Q) 여러분의 프로그램에 'Hello World'라는 문자열 리터럴이 10번 등장한다면 이 문자열을 저장하는 데 메모리가 얼마나 소모될까?
<br>
<p>
자바9 이전에는 문자당 2바이트가 필요한 UTF-16으로 표현했다. 자바9 이후부터는 콤팩트 문자열 기능으로 인해 ascii 문자만 포함된 경우 문자당 한 바이트로 인코딩한다. 배열에 저장할 때 문자 외에도 오버헤드, 문자열의 해시코드, 바이트 배열을 가리키는 참조, 인코딩의 종류를 나타내는 플래그, 바이트 배열의 오버헤드를 저장해 필요한 메모리는 48바이트이다.
</p>

### 돌발 퀴즈 2
Q) 타입 파라미터 T에 대해 `new T[10]`이 적법한 자바 표현식이 아닌 이유는?
<br>


### 돌발 퀴즈 3
Q) set이 HashSet 타입이라면 set.contains(x)를 호출해 다음 호출 set.contains(y)의 속도가 개선될 수 있을까? set이 TreeSet이라면 어떨까?
<br>


### 돌발 퀴즈 4
Q) 딱 한 번 인스턴스화 가능한 클래스(싱글톤)는 어떻게 설계할까?
<br>
싱글턴 클래스는 생성자를 private으로 선언하고 항상 같은 인스턴스를 리턴하는 public 메서드를 제공하는 방법으로 만들 수 있다.

### 돌발 퀴즈 5
Q) 루프 while(x + 1 == x) 이 영원하게 계속되도록 변수 x의 데이터 타입과 초기값을 정하라.
<br>
변수 x를 float이나 double 타입으로 선언한다. 그리고 무간섭 정수 범위 밖의 값으로 초기화한다.